#include "pch.h"
#if XO_BUILD_DIRECTX
#include "UberShader.h"

namespace xo {

DXProg_Uber::DXProg_Uber()
{
	Reset();
}

void DXProg_Uber::Reset()
{
	ResetBase();

}

const char* DXProg_Uber::VertSrc()
{
	return
		"\n"
		"cbuffer PerFrame : register(b0)\n"
		"{\n"
		"	float4x4		mvproj;\n"
		"	float2			vport_hsize;\n"
		"\n"
		"	Texture2D		shader_texture;\n"
		"	SamplerState	sample_type;\n"
		"};\n"
		"\n"
		"cbuffer PerObject : register(b1)\n"
		"{\n"
		"	float4		box;\n"
		"	float4		border;\n"
		"	float4		border_color;\n"
		"	float		radius;\n"
		"};\n"
		"\n"
		"struct VertexType_PTC\n"
		"{\n"
		"	float4 pos		: POSITION;\n"
		"	float2 uv		: TEXCOORD0;\n"
		"	float4 color	: COLOR;\n"
		"};\n"
		"\n"
		"struct VertexType_PTCV4\n"
		"{\n"
		"	float4 pos		: POSITION;\n"
		"	float2 uv		: TEXCOORD1;\n"
		"	float4 color	: COLOR;\n"
		"	float4 v4		: TEXCOORD2;\n"
		"};\n"
		"\n"
		"float fromSRGB_Component(float srgb)\n"
		"{\n"
		"	float sRGB_Low	= 0.0031308;\n"
		"	float sRGB_a	= 0.055;\n"
		"\n"
		"	if (srgb <= 0.04045)\n"
		"		return srgb / 12.92;\n"
		"	else\n"
		"		return pow(abs((srgb + sRGB_a) / (1.0 + sRGB_a)), 2.4);\n"
		"}\n"
		"\n"
		"float4 fromSRGB(float4 c)\n"
		"{\n"
		"	float4 linear_c;\n"
		"	linear_c.r = fromSRGB_Component(c.r);\n"
		"	linear_c.g = fromSRGB_Component(c.g);\n"
		"	linear_c.b = fromSRGB_Component(c.b);\n"
		"	linear_c.a = c.a;\n"
		"	return linear_c;\n"
		"}\n"
		"\n"
		"float4 premultiply(float4 c)\n"
		"{\n"
		"	return float4(c.r * c.a, c.g * c.a, c.b * c.a, c.a);\n"
		"}\n"
		"\n"
		"// SV_Position is in screen space, but in GLSL it is in normalized device space\n"
		"float2 frag_to_screen(float2 unit_pt)\n"
		"{\n"
		"	return unit_pt;\n"
		"}\n"
		"\n"
		"#define SHADER_TYPE_MASK     15\n"
		"#define SHADER_FLAG_TEXBG    16\n"
		"\n"
		"#define SHADER_ARC           1\n"
		"#define SHADER_RECT          2\n"
		"#define SHADER_TEXT_SIMPLE   3\n"
		"#define SHADER_TEXT_SUBPIXEL 4\n"
		"struct VertexType_Uber\n"
		"{\n"
		"	float2	pos     : POSITION;\n"
		"	float4	uv0     : TEXCOORD0;\n"
		"	float4	uv1     : TEXCOORD1;\n"
		"	float4	color0  : COLOR0;\n"
		"	float4	color1  : COLOR1;\n"
		"	uint	shader  : BLENDINDICES;\n"
		"};\n"
		"\n"
		"struct VSOutput\n"
		"{\n"
		"	float4 pos		: SV_Position;\n"
		"	float4 color0	: COLOR0;\n"
		"	float4 color1	: COLOR1;\n"
		"	float4 uv0	    : TEXCOORD0;\n"
		"	float4 uv1	    : TEXCOORD1;\n"
		"	uint   shader   : BLENDINDICES;\n"
		"};\n"
		"\n"
		"// CPU -> Vertex Shader: 8 + 2 * 16 + 3 * 4 = 52 bytes per vertex\n"
		"// Vertex -> Fragment:   8 + 4 * 16 + 4     = 72 bytes per fragment\n"
		"\n"
		"VSOutput main(VertexType_Uber vertex)\n"
		"{\n"
		"	VSOutput output;\n"
		"	output.pos = mul(mvproj, float4(vertex.pos.x, vertex.pos.y, 0, 1));\n"
		"	output.uv0 = vertex.uv0;\n"
		"	output.uv1 = vertex.uv1;\n"
		"	// You might be tempted to premultiply right here, but unfortunately the subpixel text renderer needs the RGB values unassociated.\n"
		"	output.color0 = fromSRGB(vertex.color0);\n"
		"	output.color1 = fromSRGB(vertex.color1);\n"
		"	output.shader = vertex.shader;\n"
		"	return output;\n"
		"}\n"
;
}

const char* DXProg_Uber::FragSrc()
{
	return
		"\n"
		"cbuffer PerFrame : register(b0)\n"
		"{\n"
		"	float4x4		mvproj;\n"
		"	float2			vport_hsize;\n"
		"\n"
		"	Texture2D		shader_texture;\n"
		"	SamplerState	sample_type;\n"
		"};\n"
		"\n"
		"cbuffer PerObject : register(b1)\n"
		"{\n"
		"	float4		box;\n"
		"	float4		border;\n"
		"	float4		border_color;\n"
		"	float		radius;\n"
		"};\n"
		"\n"
		"struct VertexType_PTC\n"
		"{\n"
		"	float4 pos		: POSITION;\n"
		"	float2 uv		: TEXCOORD0;\n"
		"	float4 color	: COLOR;\n"
		"};\n"
		"\n"
		"struct VertexType_PTCV4\n"
		"{\n"
		"	float4 pos		: POSITION;\n"
		"	float2 uv		: TEXCOORD1;\n"
		"	float4 color	: COLOR;\n"
		"	float4 v4		: TEXCOORD2;\n"
		"};\n"
		"\n"
		"float fromSRGB_Component(float srgb)\n"
		"{\n"
		"	float sRGB_Low	= 0.0031308;\n"
		"	float sRGB_a	= 0.055;\n"
		"\n"
		"	if (srgb <= 0.04045)\n"
		"		return srgb / 12.92;\n"
		"	else\n"
		"		return pow(abs((srgb + sRGB_a) / (1.0 + sRGB_a)), 2.4);\n"
		"}\n"
		"\n"
		"float4 fromSRGB(float4 c)\n"
		"{\n"
		"	float4 linear_c;\n"
		"	linear_c.r = fromSRGB_Component(c.r);\n"
		"	linear_c.g = fromSRGB_Component(c.g);\n"
		"	linear_c.b = fromSRGB_Component(c.b);\n"
		"	linear_c.a = c.a;\n"
		"	return linear_c;\n"
		"}\n"
		"\n"
		"float4 premultiply(float4 c)\n"
		"{\n"
		"	return float4(c.r * c.a, c.g * c.a, c.b * c.a, c.a);\n"
		"}\n"
		"\n"
		"// SV_Position is in screen space, but in GLSL it is in normalized device space\n"
		"float2 frag_to_screen(float2 unit_pt)\n"
		"{\n"
		"	return unit_pt;\n"
		"}\n"
		"\n"
		"#define SHADER_TYPE_MASK     15\n"
		"#define SHADER_FLAG_TEXBG    16\n"
		"\n"
		"#define SHADER_ARC           1\n"
		"#define SHADER_RECT          2\n"
		"#define SHADER_TEXT_SIMPLE   3\n"
		"#define SHADER_TEXT_SUBPIXEL 4\n"
		"\n"
		"struct VSOutput\n"
		"{\n"
		"	float4 pos		: SV_Position;\n"
		"	float4 color0	: COLOR0;\n"
		"	float4 color1	: COLOR1;\n"
		"	float4 uv0	    : TEXCOORD0;\n"
		"	float4 uv1	    : TEXCOORD1;\n"
		"	uint   shader   : BLENDINDICES;\n"
		"};\n"
		"\n"
		"struct PSOutput\n"
		"{\n"
		"	float4 color0	: SV_Target0;\n"
		"	float4 color1	: SV_Target1;\n"
		"};\n"
		"\n"
		"PSOutput write_color(float4 color)\n"
		"{\n"
		"	PSOutput pout;\n"
		"	pout.color0 = color;\n"
		"	pout.color1 = color.aaaa;\n"
		"	return pout;\n"
		"}\n"
		"\n"
		"float4 blend_over(float4 a, float4 b)\n"
		"{\n"
		"	return (1.0 - b.a) * a + b;\n"
		"}\n"
		"\n"
		"PSOutput main(VSOutput input)\n"
		"{\n"
		"	//int shader = int(input.shader);\n"
		"	uint shader = input.shader;\n"
		"	bool enableBGTex = (shader & SHADER_FLAG_TEXBG) != 0;\n"
		"	shader = shader & SHADER_TYPE_MASK;\n"
		"	PSOutput output;\n"
		"\n"
		"	if (shader == SHADER_ARC)\n"
		"	{\n"
		"		float2 center1 = input.uv0.xy;\n"
		"		float2 center2 = input.uv0.zw;\n"
		"		float radius1 = input.uv1.x;\n"
		"		float radius2 = input.uv1.y;\n"
		"		float2 uv = input.uv1.zw;\n"
		"		float4 bg_color = premultiply(input.color0);\n"
		"		float4 border_color = premultiply(input.color1);\n"
		"\n"
		"		float4 bg_tex = float4(0, 0, 0, 0);\n"
		"		if (enableBGTex)\n"
		"		{\n"
		"			bg_tex = premultiply(shader_texture.Sample(sample_type, uv));\n"
		"			bg_color = blend_over(bg_color, bg_tex);\n"
		"		}\n"
		"\n"
		"		float2 screen_pos = frag_to_screen(input.pos.xy);\n"
		"		float distance1 = length(screen_pos - center1);\n"
		"		float distance2 = length(screen_pos - center2);\n"
		"		float color_blend = clamp(distance1 - radius1 + 0.5, 0.0, 1.0);\n"
		"		float alpha_blend = clamp(radius2 - distance2 + 0.5, 0.0, 1.0);\n"
		"		float4 color = lerp(bg_color, border_color, color_blend);\n"
		"		color *= alpha_blend;\n"
		"		output = write_color(color);\n"
		"	}\n"
		"	else if (shader == SHADER_RECT)\n"
		"	{\n"
		"		float border_width = input.uv0.x;\n"
		"		float border_distance = input.uv0.y;\n"
		"		float2 uv = input.uv0.zw;\n"
		"		float4 bg_color = premultiply(input.color0);\n"
		"		float4 border_color = premultiply(input.color1);\n"
		"\n"
		"		// Distance from edge.\n"
		"		// We target fragments that are targeted at pixel centers, so if border_distance = 0.5, then alpha must be 1.0.\n"
		"		// Our alpha must drop off within a single pixel, so then at border_distance = -0.5, alpha must be 0.\n"
		"		// What we're thus looking for is a line of slope = 1.0, which passes through 0.5.\n"
		"		float edge_alpha = clamp(border_distance + 0.5, 0.0, 1.0);\n"
		"\n"
		"		// The +0.5 here is the same as above\n"
		"		float dclamped = clamp(border_width - border_distance + 0.5, 0.0, 1.0);\n"
		"\n"
		"		float4 bg_tex = float4(0, 0, 0, 0);\n"
		"		if (enableBGTex)\n"
		"		{\n"
		"			bg_tex = premultiply(shader_texture.Sample(sample_type, uv));\n"
		"			bg_color = blend_over(bg_color, bg_tex);\n"
		"		}\n"
		"\n"
		"		float4 color = lerp(bg_color, border_color, dclamped);\n"
		"		color *= edge_alpha;\n"
		"		output = write_color(color);\n"
		"	}\n"
		"	else if (shader == SHADER_TEXT_SIMPLE)\n"
		"	{\n"
		"		float4 texCol = shader_texture.Sample(sample_type, input.uv0.xy);\n"
		"		output = write_color(texCol.rrrr * premultiply(input.color0));\n"
		"	}\n"
		"	else if (shader == SHADER_TEXT_SUBPIXEL)\n"
		"	{\n"
		"		float offset = 1.0 / XO_GLYPH_ATLAS_SIZE;\n"
		"		float2 uv = input.uv0.xy;\n"
		"		float4 tex_clamp = input.uv1;\n"
		"\n"
		"		float tap0 = shader_texture.Sample(sample_type, float2(clamp(uv.x - offset * 3.0, tex_clamp.x, tex_clamp.z), uv.y)).r;\n"
		"		float tap1 = shader_texture.Sample(sample_type, float2(clamp(uv.x - offset * 2.0, tex_clamp.x, tex_clamp.z), uv.y)).r;\n"
		"		float tap2 = shader_texture.Sample(sample_type, float2(clamp(uv.x - offset * 1.0, tex_clamp.x, tex_clamp.z), uv.y)).r;\n"
		"		float tap3 = shader_texture.Sample(sample_type, float2(clamp(uv.x             ,   tex_clamp.x, tex_clamp.z), uv.y)).r;\n"
		"		float tap4 = shader_texture.Sample(sample_type, float2(clamp(uv.x + offset * 1.0, tex_clamp.x, tex_clamp.z), uv.y)).r;\n"
		"		float tap5 = shader_texture.Sample(sample_type, float2(clamp(uv.x + offset * 2.0, tex_clamp.x, tex_clamp.z), uv.y)).r;\n"
		"		float tap6 = shader_texture.Sample(sample_type, float2(clamp(uv.x + offset * 3.0, tex_clamp.x, tex_clamp.z), uv.y)).r;\n"
		"\n"
		"		float w0 = 0.56;\n"
		"		float w1 = 0.28;\n"
		"		float w2 = 0.16;\n"
		"		//float w0 = 0.60;\n"
		"		//float w1 = 0.28;\n"
		"		//float w2 = 0.12;\n"
		"\n"
		"		// Note that input.color0 needs to be non-premultiplied here.\n"
		"\n"
		"		float r = (w2 * tap0 + w1 * tap1 + w0 * tap2 + w1 * tap3 + w2 * tap4);\n"
		"		float g = (w2 * tap1 + w1 * tap2 + w0 * tap3 + w1 * tap4 + w2 * tap5);\n"
		"		float b = (w2 * tap2 + w1 * tap3 + w0 * tap4 + w1 * tap5 + w2 * tap6);\n"
		"		float aR = r * input.color0.a;\n"
		"		float aG = g * input.color0.a;\n"
		"		float aB = b * input.color0.a;\n"
		"		float avgA = (r + g + b) / 3.0;\n"
		"\n"
		"		// See the long explanation inside write_color for more details. In order to be consistent with regular\n"
		"		// (non-sub-pixel) rendering, we need to premultiply our RGB here with their respective alpha values.\n"
		"		output.color0 = float4(input.color0.r * aR, input.color0.g * aG, input.color0.b * aB, avgA);\n"
		"		output.color1 = float4(aR, aG, aB, avgA);\n"
		"	}\n"
		"	else\n"
		"	{\n"
		"		output = write_color(float4(1, 1, 0, 1));\n"
		"	}\n"
		"	return output;\n"
		"}\n"
;
}

const char* DXProg_Uber::Name()
{
	return "Uber";
}


bool DXProg_Uber::LoadVariablePositions()
{
	int nfail = 0;

	if (nfail != 0)
		Trace("Failed to bind %d variables of shader Uber\n", nfail);

	return nfail == 0;
}

uint32_t DXProg_Uber::PlatformMask()
{
	return Platform_All;
}

xo::VertexType DXProg_Uber::VertexType()
{
	return VertexType_Uber;
}

} // namespace xo

#endif // XO_BUILD_DIRECTX

